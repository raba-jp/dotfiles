[[plugins]]
repo = 'altercation/vim-colors-solarized'
hook_add = '''
  set background=dark
  let g:solarized_termtrans = 1
  let g:solarized_termcolors = 256
  augroup ColorScheme
    autocmd!
    au ColorScheme VimEnter * nested colorscheme solarized
  augroup END
'''

[[plugins]]
repo = 'itchyny/lightline.vim'
hook_add = '''
  let g:lightline = {
    \ 'colorscheme': 'solarized',
    \ 'active': {
    \   'left': [
    \     ['mode', 'paste'],
    \     ['filename', 'denite_source']
    \   ],
    \   'right': [
    \     ['lineinfo'],
    \     [],
    \     ['filetype_emoji', 'ale_error', 'ale_warning', 'ale_ok'],
    \   ]
    \ },
    \ 'component_function': {
    \   'filename': 'LightLineFileName',
    \   'mode': 'LightLineMode',
    \   'linter': 'LightLineLinterStatus',
    \   'denite_source': 'LightLineDeniteSource',
    \   'filetype_emoji': 'LightLineFileTypeEmoji'
    \  },
    \ 'component_expand': {
    \   'ale_error': 'LightLineAleError',
    \   'ale_warning': 'LightLineAleWarning',
    \   'ale_ok': 'LightLineAleOk'
    \ },
    \ }

  function! LightLineFileName()
    if &ft == 'denite'
      return ''
    endif
    return '' != expand('%:t') ? expand('%:t') : '[No Name]'
  endfunction

  function! LightLineMode()
    if &ft == 'denite'
      let l:mode_str = substitute(denite#get_status_mode(), "-\\| ", "", "g")
      call lightline#link(tolower(l:mode_str[0]))
      return l:mode_str
    endif

    return winwidth(0) > 60 ? lightline#mode() : ''
  endfunction

  function! LightLineDeniteSource()
    return &ft == 'denite' ? denite#get_status_sources() : ''
  endfunction

  function! LightLineFileTypeEmoji()
    let l:types = {
      \ 'go': ' Go',
      \ 'ruby': ' Ruby',
      \ 'python': ' Python',
      \ 'java': ' Java',
      \ 'scala': ' Scala',
      \ 'php': ' PHP',
      \ 'html': ' HTML',
      \ 'javascript': ' JavaScript',
      \ 'swift': ' Swift'
    \ }
    return &ft == '' ? 'no ft' : get(l:types, &ft, &ft)
  endfunction

  function! LightLineAleError() abort
    return s:ale_string(0)
  endfunction

  function! LightLineAleWarning() abort
    return s:ale_string(1)
  endfunction

  function! LightLineAleOk() abort
    return s:ale_string(2)
  endfunction

  function! s:ale_string(mode)
    if !exists('g:ale_buffer_info')
      return ''
    endif

    let l:buffer = bufnr('%')
    let l:counts = ale#statusline#Count(l:buffer)
    let [l:error_format, l:warning_format, l:no_errors] = g:ale_statusline_format

    if a:mode == 0 " Error
      let l:errors = l:counts.error + l:counts.style_error
      return l:errors ? printf(l:error_format, l:errors) : ''
    elseif a:mode == 1 " Warning
      let l:warnings = l:counts.warning + l:counts.style_warning
      return l:warnings ? printf(l:warning_format, l:warnings) : ''
    endif

    return l:counts.total == 0? l:no_errors: ''
  endfunction
'''
